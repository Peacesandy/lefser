library(coin)
library(MASS)
library(ggplot2)
kruskal.test.alt <- function(x){
  kruskal.test(x ~ group)$p.value
}
kw.res <- apply(expr, 1, kruskal.test.alt)
kw.sub <- kw.res <= 0.05
kw.sub[is.na(kw.sub)] <- FALSE

expr1 <- expr[kw.sub,]

wilcox_test_alt <- function(x, group){
  wilcox_test(x ~ group, distribution = "exact")
}

wilcox_test_pvalue <- function(x, group){
  pvalue(wilcox_test(x ~ group))
}

wilcox_test_z <- function(x, group){
  statistic(wilcox_test(x ~ group))
}

logical.list.of.subclasses <- list()
for (i in seq_along(unique(group))) {
  for (j in seq_along(unique(block))){
    logical.list.of.subclasses <- append(logical.list.of.subclasses, 
                                         list(group==sort(unique(group))[i] & block==sort(unique(block))[j]))
  }
}


pval_mat <- matrix(0, nrow(expr1), length(unique(block))^length(unique(group)))
z_mat <- matrix(0, nrow(expr1), length(unique(block))^length(unique(group)))

rownames(pval_mat) <- rownames(expr1)
rownames(z_mat) <- rownames(expr1)
c <- 0
for (i in seq_along(unique(block))){
  for (j in seq_along(unique(block))){
    j <- j+length(unique(block))
    mat = cbind(expr1[,logical.list.of.subclasses[[i]] ], 
                expr1[, logical.list.of.subclasses[[j]] ])
    group_for_mat = factor(c(rep(0,count(logical.list.of.subclasses[[i]]==TRUE)), 
                             rep(1, count(logical.list.of.subclasses[[j]]==TRUE))))
    pval_mat[,c+1] <- apply(mat, 1, wilcox_test_pvalue, group = group_for_mat)
    z_mat[,c+1] <- apply(mat, 1, wilcox_test_z, group = group_for_mat)
    c=c+1
  }
}

num_comp <- length(unique(block))^length(unique(group))
logical_pval_mat <- pval_mat<=0.05
sub <- which(rowSums(logical_pval_mat)==num_comp)
z_mat_sub <- z_mat[sub,]

sub <- abs(rowSums(z_mat_sub))==abs(rowSums(abs(z_mat_sub)))
expr1_sub <- expr1[names(sub), ]

expr1_sub_t <- t(expr1_sub)
expr1_sub_t <- cbind(expr1_sub_t, class = (as.numeric(group)-1))
expr1_sub_t_df <- data.frame(expr1_sub_t)

df <- expr1_sub_t_df
for (i in seq_along(c(1:(ncol(df)-1)))){
  for (j in seq_along(groups)){
    equality = df[df[,"class"]==groups[j],i]
    if (length(unique(equality))> max(length(equality)*0.5, 4)){
      next
    }else{
      for (k in seq_along(equality)){
        equality[k]=abs(equality[k] + rnorm(1, mean=0, sd=max(equality[k]*0.05, 0.01)))
      }
      
    }
    df[df[,"class"]==groups[j],i] = equality
  }
}

expr1_sub_t_df <- df

lfk <- nrow(expr1_sub_t_df)
rfk <- floor(lfk*2/3)
ncl <- length(groups)
min_cl <- as.integer(min(table(expr1_sub_t_df$class))*2/3*2/3*0.5)
min_cl <- max(min_cl,1)
pairs <- combn(groups,2)

contast_within_classes_or_few_per_class <- function(expr1_sub_t_df, rand_s, min_cl, ncl){
  cols <- expr1_sub_t_df[rand_s,]
  cls <- expr1_sub_t_df$class[rand_s]
  if (length(unique(cls)) < ncl){
    return (TRUE)
  }
  if (TRUE %in% c(table(cls) < min_cl)){
    return (TRUE)
  }
  drops <- c("class")
  by_class <- lapply(seq_along(groups), function(x){cols[cols[, "class"]==groups[x],!(names(cols) %in% drops)]})
  
  for (i in seq_along(groups)){
    unique_counts_per_microb = apply(by_class[[i]],2, function(x){length(unique(x))})
    if((TRUE %in% c(unique_counts_per_microb <= min_cl) & min_cl > 1) | (min_cl==1 & (TRUE %in% c(unique_counts_per_microb <= 1)))){
      return (TRUE)
    }
  }
  return (FALSE)
  
}

lda_fn <- function (data){
  
  for (j in seq_along(1:1000)){
    rand_s <- sample(c(1:lfk),rfk, replace=TRUE)
    if(!contast_within_classes_or_few_per_class(data, rand_s, min_cl, ncl)){
      break
    }
  }
  lda.fit <- lda(class ~., data = data, subset = rand_s)
  w <- lda.fit$scaling[,1]
  w.unit <- w/sqrt(sum(w^2))
  sub_d <- data[rand_s,]
  ss <- sub_d[,-match("class",colnames(sub_d))]
  xy.matrix <- as.matrix(ss)
  LD <- xy.matrix%*%w.unit
  effect_size <- abs(mean(LD[sub_d[,"class"]==0])-mean(LD[sub_d[,"class"]==1]))
  scal <- w.unit * effect_size
  rres <- lda.fit$means
  rowns <- rownames(rres)
  lenc <- length(colnames(rres))
  
  coeff <-vector("numeric", length(scal))
  for (v in seq_along(scal)){
    if (is.na(scal[v])!=TRUE){
      coeff[v]<-abs(scal[v])
      }else{
        coeff[v]<-0
      }
      
    }
  
  lda.means.diff <- (lda.fit$means[2,]-lda.fit$means[1,])
  (lda.means.diff+coeff)/2
}

eff_size_mat <- replicate(30, suppressWarnings(lda_fn(expr1_sub_t_df)), simplify=T)

raw_lda_scores <- rowMeans(eff_size_mat)

processed_scores <- sign(raw_lda_scores)*log((1+abs(raw_lda_scores)),10)

processed_sorted_scores <- sort(processed_scores)

Names <- vector("character", length(processed_sorted_scores))
for (i in seq_along(processed_sorted_scores)){
  vec_of_strings = unlist(strsplit(names(processed_sorted_scores)[i], "[.]"))
  Names[i] = vec_of_strings[length(vec_of_strings)]
}

scores_df <- data.frame(Names, scores <- as.vector(processed_sorted_scores))


ggplot(scores_df, aes(reorder(Names, scores), scores)) +ylab("LDA SCORE (log 10)") +
  theme(axis.title.y = element_blank(),
        axis.title.x =element_text(size=11,face="bold"),
        axis.text.y  = element_text(vjust=0.7, size=9,face="bold"),
        axis.text.x  = element_text(vjust=0.7, size=9,face="bold"),
        plot.title = element_text(hjust=0.5, size=13, face="bold"))+
  geom_bar(stat = "identity", fill = ifelse(scores_df$scores > 0, "forestgreen", "red")) +  coord_flip()

